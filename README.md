<h2>1. Project 주제</h2>
Socket 통신을 활용하여 Tic-Tac-Toe game을 구현한다.

<h2>2. Project를 위한 배경 지식</h2>
TCP는 어플리케이션 간의 데이터 전송을 위해서 안정적인 connection을 제공한다. HTTP 는 어플
리케이션 안에서 돌아가고 어플리케이션 layer는 Client - Server Paradigm 과 Peer - Peer 
Architecture가 있다. client - server Paradigm은 server가 중개 역할을 하며 통신을 하는 것이고, 
Peer - Peer Architecture는 Peer 간 1 : 1로 direct로 통신하는 것이다. Socket은 프로세스가 네트워
크 세계로 데이터를 내보내거나 네트워크 세계로부터 데이터를 받기 위한 창구 역할을 한다. 프
로세스가 데이터를 수신하거나 송신하기 위해선 socket을 열어서 데이터를 작성하거나 Socket으
로부터 데이터를 읽어야 한다. Socket은 Protocol, IP 주소, Port number로 구성되어 있다. Protocal
은 시스템 간의  통신을 원활하게 해주는 통신 규약이고, IP는 전 세계 컴퓨터에 부여된 고유의 
식별 주소이다. 마지막으로 Port는 한 호스트 내에서 네트워크 통신을 하고 있는 프로세스를 식별
하기 위해서 사용되는 값이다. 즉 Socket 은 두 호스트를 연결해주는 인터페이스 역할을 하고, 데
이터를 주고 받을 수 있는 구조체이다. 
Socket은 클라이언트와 서버 나 peer to peer로 상호작용한다 일반적으로 서버를 한 시스템에 두
고 클라이언트를 다른 시스템에 둔다. 클라이언트는 서버에 연결하여 정보를 교환한 후 연결을 
끊는다. 이러한 방법으로 두 프로그램이 네트워크를 통해서 서로 통신할 수 있게 된다. 
Socket 통신의 흐름은 다음과 같다. 서버는 Socket을 생성하고 ip와 port번호를 바이드한다. 
‘Listen()’으로 클라이언트 요청에 대기열을 만들어서 몇 개의 클라이언트를 대기 시킬지 결정한다. 
‘accept’로 클라이언트와 연결 후 데이터를 송수신한다. 연결이 끝나면 Socket을 닫는다. 클라이언
트는 Socket을 생성하고 서버에 설정된 IP, Port 정보로 연결을 시도한다. ‘accept()’로 클라이언트의 
socket descriptor 반환한다. 데이터를 송수신 후 연결이 끝나면 Socket을 닫는다.   

<h2>3. project 가정</h2> 
온라인으로 Tic-Tac-Toe game을 할려고 한다. 플레이어는 2명이다. 3X3 board가 주어지고, 먼저 플
레이를 하는 사람이 ‘X’ 나중에 플레이 하는 사람이 ‘O’를 가지고 보드에 표시하게 된다. 플레이어
들은 번갈아면서 한칸씩 보드에 표시하게 되고 가로, 세로, 대각선으로 3줄을 만든 플레이어가 우
승하게 된다. 
이 Project는 Socket 관점으로 보면, Client – Server Paradigm으로 보이지만 기능적으로 접근하면 
Peer to Peer으로 동작한다. 한 peer는 client, 한 peer는 server가 되어서 게임이 진행된다. 
Protocal은 ETTTP(HTTP의 가짜버전)로 정하였다. Server는 선 플레이어를 골라서 client에게 알려
준다.  
1) 자신의 차례가 아닐 때, 클릭되거나 입력된 값은 버린다. 
2) 받은 메시지가 형식에 맞지 않으면 프로그램을 종료시킨다. 
3) 좌표가 포함된 SEND 메시지를 송신하고 ACK을 받았을 때 보드에 표시한다. 
4) 상대방이 보낸 SEND 메세지에서 좌표를 읽고 ACK을 보낸 후 자신의 보드에 표시한다. 
5) 3줄이 완성되어서 게임이 종료되면 승패 여부를 각자 창에 표시한다. 

<h2>4. Project에서 중요한 파트</h2>
1) Server가 선 플레이어를 정해서 Client에게 메시지를 송신한다. 
(1) Server 가 랜덤으로 숫자를 선택한다.(0 - server, 1 – client) 
(2) Server가 숫자를 포함한 SEND 메세지를 Client에게 송신한다. 
(3) Client는 수신한 메시지가 형식에 맞는 지 확인하고, ACK 메시지를 Server에게 송신한다. 
(3) Server는 수신한 ACK 메시지가 형식에 맞는 지 확인한다. 
2) 보드를 클릭할 때마다 커뮤니케이션 진행 
(1) 클릭된 자리를 좌표로 치환하고 SEND 메시지를 작성한다. 
(2) Peer가 좌표를 포함한 SEND 메세지를 상대방 Peer에게 송신한다. 
(3) SEND 메세지를 수신한 Peer는 수신한 메시지가 형식에 맞는 지 확인하고, ACK 메시지를 상
대방에게 전송한다. 그 후 보드에 표시한다.  
(4) ACK 메시지를 수신한 Peer는 수신한 ACK 메시지가 형식에 맞는 지 확인한 후 보드에 표시한
다. 
3) 2개의 프로그램에서 Final result가 서로 다르게 나타난다. 
(1) 게임이 종료 후 이긴 플레이어가 진 플레이에게 이겼다는 SEND 메시지를 작성 후 송신한다. 
(2) 진 플레이어는 이긴 플레이어에게 ACK 메시지를 송신 후 졌다는 결과를 표시한다. 
(3) ACK 메시지를 수신한 winner 플레이어는 이겼다는 결과를 표시한다. 


<h2>5. 코드 분석</h2> 
A) Client code 
1) 서버와 연결하기 위해서 socket을 생성한다 
2) 클라이언트는 서버로부터 먼저 할 플레이어의 번호가 포함된 SEND 메세지를 수신한다. 
3) 수신한 SEND 메시지에서 ‘\r\n’와 ‘:’를 공백으로 바꾸고 공백을 기준으로 문자열을 리스트로 
만든다. 
4) 리스트를 활용해서 메시지가 유효한지 확인한다. 
5) 유효하지 않다면 프로그램이 종료된다. 
6) 메시지에서 ‘first move: me’면 server가 선공이므로 start를 0으로 바꾸고 ‘first move: you’면 
client가 선공으므로 start를 1으로 바꾼다. 
7) server가 선공라면 ‘first move: you’ 라는 메시지가 포함된 ACK 메시지를 서버에게 송신하고 
Client가 선공이면 ‘first move: me’ 라는 메시지가 포함된 ACK 메시지를 서버에게 송신한다. 
8) 게임이 시작되고 게임이 종료되면 client Socket을 닫는다. 
B. Server 코드 
1) 클라이언트와 연결하기 위해서 Socket을 생성한다. 
2) 0과 1 중 랜덤으로 숫자를 뽑고 Start 변수에 넣는다. 
3) 뽑은 선 플레이어를 포함한 SEND 메시지를 작성한다. 
4) 문자열 SEND 메시지를 인코딩하여 Socket을 통해서 Client에게 송신한다. 
5) 클라이언트에게 ACK 메시지를 수신한다. 
6) ACK 메시지의 유효성을 파악 후 유효하지 않다면 프로그램이 종료된다. 
7) 메시지가 유효한 지 파악하는 방법은 다음과 같다. 
7.1) ‘\r/n/’와 ‘:’를 공백으로 바꾸고 공백을 기준으로 리스트를 만든다. 
7.2) 리스트에서 host, ip, 명령어, 선 플레이어 등이 맞는 지 확인한다. 
7.3) start 가 0이면 YOU 가 start가 1이면 ME가 맞는 지 확인한다. 
8) 게임을 시작한다 
9) 게임이 종료되면 클라이언트 Socket을 닫아준다. 
10) Server Socket도 닫아준다. 

C. Tic-Tac-Toe code 
1) 객체를 생성하고 값을 초기화하고 GUI를 만들어준다. 
2) 프로그램이 시작되면, Frame을 띄우고 Start Player가 ‘X’를 가지게 된다. 
3) 자기 turn인 플레이어 창에서 Ready를 표시하게 된다. 다른 창은 Hold를 표시한다. 
4) 플레이어는 표시할 자리를 선택하게 된다 이 때 두가지 방법이 있다.  
4.1) 마우스로 자리를 클릭한다. 
4.1.1) 자기 turn이 아니면 클릭이 안된다. 
4.1.2) 클릭된 자리를 좌표로 치환한다. 
4.2) 텍스트 박스에 메시지를 입력한다. 
4.2.1) ‘SEND ETTTP/1.0\r\nHost:<send_ip>\r\nNew-Move: <좌표>\r\n\r\n’의 형태로 텍스
트를 작성한 후 ‘Send’ 버튼을 클릭한다. 
4.2.2) 자신의 차례가 아니면 입력받은 텍스트를 삭제하고 리턴한다. 
4.2.3) 입력받은 메시지를 변수 d_msg에 저장하고 텍스트 박스에 입력받은 문자열은 삭제한다. 
4.2.4) 메시지를 유효성 검사한다. 
4.2.5) 메시지가 유효하다면, 좌표를 도출해낸다.    
5) ‘send_move’ 함수에게 매개변수로 좌표를 넘겨준다. 
6) ‘send_move’ 함수는 넘겨받은 좌표에서 행과 열을 추출하고 SEND 메시지를 작성한다. 
7) SEND 메시지를 송신한다.  
8) SEND 메시지를 수신 받은 상대방은 SEND 메시지를 유효성 검사한다. 
9) 메시지가 유효하면, 메시지에서 좌표의 행과 열을 추출한다. 
10) ACK 메시지를 수신하고 보드에 표시한다. 
11) ACK 메시지를 받은 Peer은 ACK 메시지를 유효성 검사한다. 
12) 메시지가 유효하면 True를 return해서 차례를 넘겨주게 되고 보드에 좌표를 표시한다. 
13) 게임이 끝나지 않았으면 윗 줄 “3)” 으로 돌아가서 반복한다. 
14) 3줄 완성으로 게임이 종료되면, 2개의 창에 결과를 각각 표시해준다. 
